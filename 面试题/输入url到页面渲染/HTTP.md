# HTTP 超文本传输协议 /0.9
 - 基于TCP 
 - 只有请求行和响应行   GET /index.html
 - 以 ASCII 字符流的编码方式进行传输

 # HTTP 1.0
 - 0.9的缺点：支支持html一种类型的资源传输

 支持 js，css，图片，音频，视频各种类型资源

 - 请求头
    accept:text/html
    accept-encoding: gzip deflate br
    accept-language: zh-CN

 - 响应头
    content-type: text/html
    Content-Length:1024 后端内容动态生成，无法确定数据大小

 - 为了传输不同的类型资源而诞生的

 # HTTP 1.1
 - 持久连接，减轻了服务器的负担
 - 同时最多维护6个持久连接

 - 队头阻塞
    1. 前一个http请求没有得到响应，后一个http请求无法响应

 - HOST
    为了解决在一台服务器上托管多个域名（虚拟主机）的情况。通过 Host 头字段，客户端可以告诉服务器请求的是哪个具体的域名，从而服务器能够根据不同的域名来处理请求，实现虚拟主机的功能。

 - 为了解决后端动态生成内容的问题，引入了chunked
    Chunk transfer 机制:将资源文件处理成若干个数据块并编辑数据块的大小，最后发送一个标记为 0 的数据块来告诉客户端资源传输完成

 # HTTP 2.0
 - 1.1 缺点
   1. 队头阻塞
   2. 带宽利用率低
      1) 同时开启多条持久连接，会相互之间竞争带宽
      2) TCP 的慢启动，拖延了页面首次渲染的时间
      3) 队头阻塞 （前一个http请求被阻塞5s后一个http又不能发送，那么该5s的时间内带宽就被浪费了）

 - 一次只能维持一个TCP长连接
 - 多路复用
      将每一个请求处理成一帧一帧的请求片段（二进制分帧层），并给每一帧打上标记，服务端接收到所有的帧之后，会将标记相同的帧组合成完整的请求，然后进行解析，响应请求，最后将响应数据发送给客户端，响应体同样会被处理成一帧一帧的请求。

 # HTTPS
   在HTTP 2.0的基础上做了加密的处理
   HTTP + TLS加密协议

   对称加密
      双方都要拥有相同的密钥，密钥用于对数据的加密和解密，如何让双方具有相同的密钥？使用网络传输，一旦在传输密钥的阶段被截获，接下来的加密就没有意义

   非对称加密
      为了解决密钥被截获的问题，引入了非对称加密，使用公钥加密，使用私钥解密。
      首先服务端创建公钥和私钥，并将公钥发布出去，客户端创建密钥，通过密钥加密传递给客户端，服务端通过独有的私钥进行解密得到正确的密钥

 # HTTP 3.0
   2.0 的缺点
      1. TCP 队头阻塞：当存在数据包丢失时，TCP会重传一个新的包，在新包传递前，后续的数据包会被暂停传输
      2. TCP 握手 也是时间的开销大

      - TCP 协议僵化

      - 改UDP --- QUIC协议
         1. 在UDP上实现了TCP的拥塞控制，可靠性传输
         2. 继承了TLS加密功能
         3. 实现了多路复用
         4. 快速握手