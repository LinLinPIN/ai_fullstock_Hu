1. 手动回收
2. 自动回收

# 代际假说
     1. 大部分的对象在内存中存在的时间是很短的
     2. 不死的对象，会活得更久

# 分代收集

# v8
  堆被分为新生代区和老生代区
  新生代区：副垃圾回收器        老生代区：主垃圾回收器
      标记空间中的活动对象和非活动(活动对象：还在使用的对象，非活动对象：要被回收的对象)
      回收非活动对象的空间
      整理内存碎片

  - 副垃圾回收器
        将新生代区分为对象空间和空闲空间，对象空间用于存放新进的小对象，当存满后执行回收处理，再将存活的对象复制到空闲空间，此时就做好了内存整理，再反转对象空间和空闲空间。新对象空间继续接受对象（两次回收仍存活的对象会晋升到老生代区）

  - 主垃圾回收器
        因为存放的对象都比较大，所以不适合用副垃圾回收器相同的算法，只能采用标记清除法，递归一个对象，当对象中任何一个属性都没被使用，则作为垃圾回收掉，再整理空间

# 全停顿
    - js运行再v8的主线程上，当垃圾回收机制生效时，js的执行要让出线程，那么js执行就会暂停
    - 解决方法：增量标记法，将垃圾回收机制过程中的标记过程拆分成很多个小问题，和js执行来回切换执行