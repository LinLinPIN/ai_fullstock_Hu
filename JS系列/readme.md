# 1. js数组上面有哪些方法？
1. 增加: unshift push splice concat
2. 删除: pop shift splice slice
3. 改: reverse sort with
4. 查: indexOf lastIndexOf includes find
5. 转换: join
6. 迭代: forEach map filter some every
7. Array.from()伪数组转真数组   Array.of()将多个值转为数组

# 2. js字符串上有哪些方法？
1. 增: concat padStart
2. 删: slice substr删除到哪一个下标 substring与slice一样
3. 改: replace trim trimStart trimEnd padStart toUpperCase
4. 查: indexOf lastIndexOf includes EndWith startWith是否是以什么东西开头 
5. 转换: split

# 3. 谈谈js中的类型转换机制
- 是什么:
js中有原始类型和引用类型:
原始类型: number string symbol boolean undefined null Bigint
引用类型: arr Object function Data Regexp Set Map

通常开发过程中，会用到一些显示类型转换的手段来完成逻辑开发
Number()

在v8执行过程中还存在另一种转换 ———— 隐式类型转换

通常发生在比较运算符 和 算术运算符
[] ==![]

## 对象转原始类型    obj.toString()      obj.valueOf() 对包装类生效
toString() 在js中有多个版本
- {}.toString() // "[Object class]"
- 数组的toString()会将数组中所有的元素转化为字符串，并以逗号拼接
- 函数的toString()会将整个函数体以字符串形式返回
- Date的toString()会将整个date以字符串形式返回



## 对象转字符串     ToPrimitive(obj,String)
1. 判断obj是基本类型，则返回
2. 否则调用 toString 方法，如果得到原始类型则返回
3. 否则调用 valueOf 方法，如果得到原始类型，则返回
4. 否则 报类型错误

## 对象转数字   ToPrimitive(obj,number)
1. 判断obj是基本类型，则返回
2. 否则调用 valueOf 方法，如果得到原始类型，则返回
3. 否则调用 toString 方法，如果得到原始类型，则返回
4. 否则 报类型错误

# 4. == 和 === 的区别？
    == 只判断值是否相等，类型不相等时会发生隐式类型转换

# 5. 深浅拷贝的区别？如何实现一个深拷贝？
- 深浅拷贝通常只针对引用类型

- 浅拷贝: 直接复制引用地址，修改对象内部的值，会改变原对象的值
只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制他的指针
assign,concat,slice,解构

- 深拷贝: 递归拷贝，复制对象内部的所有值，如果有引用类型的话，会递归拷贝
层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象
JSON.parse(JSON.stringify(obj))对象转为字符串再转回对象，无法处理对象内部的undefined，symbol，function，无法处理循环引用 obj.c = obj.b,obj.b.n = obj.c
structuredClone()   

手写浅拷贝,for in,并且判断是否是显示原型上的属性,hasOwnProperty()

手写深拷贝

# 6. 说说你对闭包的理解？
- 是什么
当一个函数中的内部函数被外部函数return出去，又因为在js中，内层作用域总是能访问外层作用域的。那么内部函数存在对外部函数的变量的引用，这些变量的集合叫做闭包，就不会被垃圾回收机制销毁。
- 闭包的优点
1. 可以访问外部函数中的变量，可以实现私有属性(全局变量难以维护)
2. 延长变量的声明周期
3. 实现柯里化(颗粒化)

- 缺点: 会造成内存泄漏
    调用栈中的变量不会被回收，因为函数执行完毕后，函数的作用域被销毁，但是由于闭包函数内部的变量不会被销毁，因为函数内部的变量被闭包引用，所以函数内部的变量不会被销毁，从而造成内存泄漏

# 7. 什么是柯里化
- 是什么
将一个接受多个参数的函数转变为多个只接受一个参数的函数

# 8. 说说你对作用域的理解
- 是什么:
作用域定义了变量和函数在程序中被识别和可访问的范围。作用域规则可以帮助确保变量名和函数名不会发生冲突。简单来说就是作用域规定了变量可见的范围，控制了变量的访问权限。
- 有哪些
1. 全局作用域
2. 函数作用域
3. 块级作用域

- 作用域链
    作用域只能由内到外的访问，这种访问规则形成的链状关系我们称之为作用域链。

- 词法作用域
    作用域是能够被修改的，词法作用域是编译器在编译代码时就确定的，不会改变的。
    函数或者变量定义的区域，定义在哪里指向哪里

# 9. 说说你对原型的理解
 对象的隐式原型等于构造函数的显示原型
 找对象身上的属性时，会先去对象内部找，找不到就回去对象的隐式原型上找也就是构造函数的显示原型

- 是什么:
1. 显示原型指的是函数身上自带的 prototype 属性，通常可以将一些属性和方法添加在显示原型上，可供实例对象继承到

2. 隐式原型  __proto__ 是对象这种结构上的一个属性,其中包含了创建该对象时，隐式继承到的属性

- 原型链: 创建一个实例对象时，实例对象的隐式原型===创建该对象的构造函数的显示原型，在js中对象的查找规则是现在对象中查找，找不到再去对象的隐式原型上查找，顺着隐式原型一层层往上找，最终找到null为止，这种查找规则我们就叫原型链

通常我们会借助原型这种手段来实现属性的继承

# 10. 说说js的继承
- 是什么:
    在js中继承指的是让一个子类可以访问父类的属性和方法的
    - 继承有哪些方式
        1. 原型链继承:
            无法给父类灵活传参
            多个实例对象共用了同一个原型对象存在属性相互影响

        2. 构造函数继承
            只能继承到到父类身上的属性，无法继承到父类原型上的属性

        3. 组合继承(经典继承)
            - 存在多次父类函数的调用，多造成了性能开销

        4. 原型式继承
            因为是浅拷贝，父类之间的引用类型在子类之间共用了，会相互影响
            子类无法添加默认属性

        5. 寄生式继承
            也是浅拷贝
            子类可以添加默认属性
        
        6. 寄生组合式继承
            - 通过寄生式继承和原型链继承的结合，解决了原型链继承的性能问题，也解决了原型链继承无法传参的问题

        7. class 继承
            
# 11. 说说js中的this
- 是什么：this是函数在运行过程中自动生成的一个对象，用来代指作用域的指向

- 绑定规则：
    1. 默认绑定: 当函数被独立调用时，函数的this被指向window
    2. 隐式绑定：当函数被某个对象调用的时候函数的this就指向这个对象 obj.foo()
    3. 隐式丢失：当函数被多个对象调用时，函数的this指向他最近的对象  obj2.obj.foo()
    4. 显示绑定：bind,apply,call
        bind返回一个函数体，需要接着调用，apply和call会直接调用
    5. new 绑定： 函数被new的时候，this指向实例对象

- 箭头函数：
    继承外层作用域的this

# 12. 说说new的实现原理
1. 创建一个空对象
2. 让实例对象的隐式原型指向构造函数的显示原型
3. 让构造函数的this指向实例对象
4. 返回实例对象

- 构造有返回值且返回值为引用类型时，会覆盖 new 当中的返回值

# 13. call,apply,bind 底层原理
    隐式绑定，让对象调用这个函数

# 14. 说说js中的事件模型
- 什么是事件流
先捕获后冒泡

- 事件模型的分类
1. DOM0级 onclick (无法控制事件在捕获冒泡哪个阶段执行)
2. DOM2级 addEventListener (可以控制事件在捕获冒泡哪个阶段执行)
3. IE模型 attachEvent（无法控制事件在捕获冒泡哪个阶段执行）

# 15. 说说typeof和instanceof的区别
- typeof
    可以判断除null外所有的基本数据类型，复杂数据类型都会输出object（通过二进制判断）以及能判定function
    console.log(typeof null)// Object

- instanceof
    能判断变量是否为引用类型（原型链查找）原始类型没有隐式原型
    let c = []
    console.log(c instanceof Object)// c.__proto__ === Object.prototype
    可以判断一个对象是否为另一个对象的实例
    无法正确判断对象是否为一个数组或者数组为一个对象

- Object.prototype.toString.call()
toString方法对于不同的数据类型，有着不同的返回值，数组的toString方法返回的是''
对象返回一个[Object,Object],所以使用call来绑定到数组上使用对象那个toString绑定到数组上来判断数组

该方法会让变量能够调用对象上的toString函数，而对象的toString方法会返回[object Object]这个种类型的值

- Array.isArray()
只能用于判断一个变量是否是数组

# 16. 说说Ajax的原理
- 是什么：
    Async Javascript and XML
    是一种异步js和网页交互的技术，可以实现不刷新网页就跟服务器交换数据，更新页面

- 实现过程
    1. 创建Xhr实例对象
    2. 调用实例对象中的open方法与服务器建立连接
    3. 调用实例对象中的send方法发送请求
    4. 监听onreadystateChange事件，通过判断readyState的值来获取到最终的数据
    5. 将数据更新到html页面