# 1. js数组上面有哪些方法？
1. 增加: unshift push splice concat
2. 删除: pop shift splice slice
3. 改: reverse sort with
4. 查: indexOf lastIndexOf includes find
5. 转换: join
6. 迭代: forEach map filter some every
7. Array.from()伪数组转真数组   Array.of()将多个值转为数组

# 2. js字符串上有哪些方法？
1. 增: concat padStart
2. 删: slice substr删除到哪一个下标 substring与slice一样
3. 改: replace trim trimStart trimEnd padStart toUpperCase
4. 查: indexOf lastIndexOf includes EndWith startWith是否是以什么东西开头 
5. 转换: split

# 3. 谈谈js中的类型转换机制
- 是什么:
js中有原始类型和引用类型:
原始类型: number string symbol boolean undefined null Bigint
引用类型: arr Object function Data Regexp Set Map

通常开发过程中，会用到一些显示类型转换的手段来完成逻辑开发
Number()

在v8执行过程中还存在另一种转换 ———— 隐式类型转换

通常发生在比较运算符 和 算术运算符
[] ==![]

# 4. == 和 === 的区别？
    == 只判断值是否相等，类型不相等时会发生隐式类型转换

# 5. 深浅拷贝的区别？如何实现一个深拷贝？
- 深浅拷贝通常只针对引用类型

- 浅拷贝: 直接复制引用地址，修改对象内部的值，会改变原对象的值
只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制他的指针
assign,concat,slice,解构

- 深拷贝: 递归拷贝，复制对象内部的所有值，如果有引用类型的话，会递归拷贝
层层拷贝，所有类型的属性值都会被复制，原对象的修改不会影响拷贝后的对象
JSON.parse(JSON.stringify(obj))对象转为字符串再转回对象，无法处理对象内部的undefined，symbol，function，无法处理循环引用 obj.c = obj.b,obj.b.n = obj.c
structuredClone()   

手写浅拷贝,for in,并且判断是否是显示原型上的属性,hasOwnProperty()

手写深拷贝

# 6. 说说你对闭包的理解？
- 是什么
当一个函数中的内部函数被外部函数return出去，又因为在js中，内层作用域总是能访问外层作用域的。那么内部函数存在对外部函数的变量的引用，这些变量的集合叫做闭包，就不会被垃圾回收机制销毁。
- 闭包的优点
1. 可以访问外部函数中的变量，可以实现私有属性(全局变量难以维护)
2. 延长变量的声明周期
3. 实现柯里化(颗粒化)

- 缺点: 会造成内存泄漏
    调用栈中的变量不会被回收，因为函数执行完毕后，函数的作用域被销毁，但是由于闭包函数内部的变量不会被销毁，因为函数内部的变量被闭包引用，所以函数内部的变量不会被销毁，从而造成内存泄漏

# 7. 什么是柯里化
- 是什么
将一个接受多个参数的函数转变为多个只接受一个参数的函数

# 8. 说说你对作用域的理解
- 是什么:
作用域定义了变量和函数在程序中被识别和可访问的范围。作用域规则可以帮助确保变量名和函数名不会发生冲突。简单来说就是作用域规定了变量可见的范围，控制了变量的访问权限。
- 有哪些
1. 全局作用域
2. 函数作用域
3. 块级作用域

- 作用域链
    作用域只能由内到外的访问，这种访问规则形成的链状关系我们称之为作用域链。

- 词法作用域
    作用域是能够被修改的，词法作用域是编译器在编译代码时就确定的，不会改变的。
    函数或者变量定义的区域，定义在哪里指向哪里

# 9. 说说你对原型的理解
 对象的隐式原型等于构造函数的显示原型
 找对象身上的属性时，会先去对象内部找，找不到就回去对象的隐式原型上找也就是构造函数的显示原型

- 是什么:
1. 显示原型指的是函数身上自带的 prototype 属性，通常可以将一些属性和方法添加在显示原型上，可供实例对象继承到

2. 隐式原型  __proto__ 是对象这种结构上的一个属性,其中包含了创建该对象时，隐式继承到的属性

- 原型链: 创建一个实例对象时，实例对象的隐式原型===创建该对象的构造函数的显示原型，在js中对象的查找规则是现在对象中查找，找不到再去对象的隐式原型上查找，顺着隐式原型一层层往上找，最终找到null为止，这种查找规则我们就叫原型链

通常我们会借助原型这种手段来实现属性的继承

# 10. 说说js的继承
- 是什么:
    在js中继承指的是让一个子类可以访问父类的属性和方法的
    - 继承有哪些方式
        1. 原型链继承:
            无法给父类灵活传参
            多个实例对象共用了同一个原型对象存在属性相互影响

        2. 构造函数继承
            只能继承到到父类身上的属性，无法继承到父类原型上的属性

        3. 组合继承(经典继承)
            - 存在多次父类函数的调用，多造成了性能开销

        4. 原型式继承
            因为是浅拷贝，父类之间的引用类型在子类之间共用了，会相互影响
            子类无法添加默认属性

        5. 寄生式继承
            也是浅拷贝
            子类可以添加默认属性
        
        6. 寄生组合式继承
            - 通过寄生式继承和原型链继承的结合，解决了原型链继承的性能问题，也解决了原型链继承无法传参的问题


                